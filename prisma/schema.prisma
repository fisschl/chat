generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

/// 用户模型
/// 存储系统用户的基本信息
model User {
  /// 用户唯一标识符
  /// 使用 UUID v7 作为默认值
  userId String @id @default(uuid(7))

  /// 用户姓名
  /// 必填字段，用于显示用户名称
  userName String

  /// 用户邮箱地址
  /// 可选字段，具有唯一性约束
  email String? @unique

  /// 用户手机号码
  /// 可选字段，具有唯一性约束
  phone String? @unique

  /// 用户密码
  /// 必填字段，使用 argon2 加密存储
  password String

  /// 用户头像
  /// 可选字段，存储用户头像的 URL
  avatar String?

  /// 创建时间
  /// 自动记录用户创建时间
  createdAt DateTime @default(now())

  /// 更新时间
  /// 自动记录用户信息更新时间
  updatedAt DateTime @updatedAt

  /// 用户的认证令牌
  /// 一对多关系，一个用户可以拥有多个认证令牌
  authTokens AuthToken[]

  /// 用户加入的频道
  /// 一对多关系，一个用户可以加入多个频道
  userChannels UserChannel[]

  /// 用户的频道访问时间记录
  /// 一对多关系，一个用户在多个频道有访问记录
  channelAccessTimes ChannelAccessTime[]

  /// 用户发送的消息
  /// 一对多关系，一个用户可以发送多条消息
  messages Message[]

  /// 用户拥有的频道
  /// 一对多关系，一个用户可以拥有多个频道
  ownerChannels Channel[]
}

/// 认证令牌模型
/// 存储用户的认证令牌信息
model AuthToken {
  /// 令牌值
  /// 主键字段，使用 longToken 生成的唯一令牌
  token String @id

  /// 关联的用户ID
  /// 必填字段，外键关联到 User 表
  userId String

  /// 关联的用户
  /// 必填字段，建立与 User 表的关系
  user User @relation(fields: [userId], references: [userId], onDelete: Cascade)

  /// 创建时间
  /// 自动记录令牌创建时间
  createdAt DateTime @default(now())

  /// 最后使用时间
  /// 记录令牌最后一次被使用的时间
  lastUsedAt DateTime @default(now())

  /// 过期时间
  expiresAt DateTime

  /// 索引：按用户ID查询
  @@index([userId])
  /// 索引：按过期时间查询
  @@index([expiresAt])
  /// 索引：按最后使用时间查询
  @@index([lastUsedAt])
}

/// 频道模型
/// 存储频道的基本信息
model Channel {
  /// 频道唯一标识符
  /// 使用 UUID v7 作为默认值
  channelId String @id @default(uuid(7))

  /// 频道名称
  /// 必填字段，用于显示频道名称
  name String

  /// 频道描述
  /// 可选字段，描述频道用途
  description String?

  /// 频道类型
  /// 必填字段，支持公开、私密、直接消息三种类型
  /// public: 公开频道，任何人都可以加入
  /// private: 私密频道，需要邀请才能加入
  /// direct: 直接消息频道，两个用户之间的私聊
  type ChannelType @default(public)

  /// 频道所有者ID
  /// 可选字段，外键关联到 User 表
  ownerId String?

  /// 频道所有者
  /// 可选字段，建立与 User 表的关系
  owner User? @relation(fields: [ownerId], references: [userId], onDelete: SetNull)

  /// 是否已归档
  /// 默认值为 false，归档后频道不再活跃
  isArchived Boolean @default(false)

  /// 频道头像
  /// 可选字段，存储频道头像的 URL
  avatar String?

  /// 创建时间
  /// 自动记录频道创建时间
  createdAt DateTime @default(now())

  /// 更新时间
  /// 自动记录频道信息更新时间
  updatedAt DateTime @updatedAt

  /// 频道成员关系
  /// 一对多关系，一个频道可以有多个成员
  userChannels UserChannel[]

  /// 频道访问时间记录
  /// 一对多关系，一个频道有多个用户的访问记录
  channelAccessTimes ChannelAccessTime[]

  /// 频道消息
  /// 一对多关系，一个频道包含多条消息
  messages Message[]

  /// 索引：按频道类型查询
  @@index([type])
  /// 索引：按所有者查询
  @@index([ownerId])
  /// 索引：按创建时间排序
  @@index([createdAt])
}

/// 用户频道关系模型
/// 存储用户与频道的多对多关系
///
/// 注意：访问时间相关字段（lastAccessedAt）存储在单独的 ChannelAccessTime 表中
/// 这样设计的原因：
/// 1. 关注点分离：此表关注用户与频道的关系，ChannelAccessTime 关注访问行为
/// 2. 性能优化：访问时间频繁更新，分开存储减少锁竞争
/// 3. 数据生命周期：用户退出频道时删除此记录，但访问时间可能保留用于分析
model UserChannel {
  /// 用户ID
  /// 必填字段，外键关联到 User 表
  userId String

  /// 频道ID
  /// 必填字段，外键关联到 Channel 表
  channelId String

  /// 加入时间
  /// 自动记录用户加入频道的时间
  joinedAt DateTime @default(now())

  /// 关联的用户
  /// 必填字段，建立与 User 表的关系
  user User @relation(fields: [userId], references: [userId], onDelete: Cascade)

  /// 关联的频道
  /// 必填字段，建立与 Channel 表的关系
  channel Channel @relation(fields: [channelId], references: [channelId], onDelete: Cascade)

  /// 联合主键：使用 userId 和 channelId 作为复合主键
  @@id([userId, channelId])
  /// 索引：按加入时间排序
  @@index([joinedAt])
}

/// 频道访问时间模型
/// 记录用户在每个频道的最后访问时间
///
/// 设计决策：为什么访问时间要单独存储，而不是放在 UserChannel 表中？
/// 1. 关注点分离：UserChannel 关注用户与频道的关系，ChannelAccessTime 关注访问行为
/// 2. 性能优化：访问时间频繁更新，分开存储可以减少对 UserChannel 表的锁竞争
/// 3. 数据生命周期不同：用户退出频道时删除 UserChannel 记录，
///    但可能保留访问时间用于分析用户行为
/// 4. 扩展性：未来可以轻松添加更多访问相关的统计信息
/// 5. 查询优化：专门为访问时间查询优化索引，提高查询效率
model ChannelAccessTime {
  /// 用户ID
  /// 必填字段，外键关联到 User 表
  userId String

  /// 频道ID
  /// 必填字段，外键关联到 Channel 表
  channelId String

  /// 最后访问时间
  /// 记录用户最后一次访问该频道的时间
  /// 用于判断用户是否阅读了频道中的所有消息
  /// 比较 lastAccessedAt 和消息的 createdAt 可以确定未读消息
  lastAccessedAt DateTime @default(now())

  /// 关联的用户
  /// 必填字段，建立与 User 表的关系
  user User @relation(fields: [userId], references: [userId], onDelete: Cascade)

  /// 关联的频道
  /// 必填字段，建立与 Channel 表的关系
  channel Channel @relation(fields: [channelId], references: [channelId], onDelete: Cascade)

  /// 联合主键：使用 userId 和 channelId 作为复合主键
  @@id([userId, channelId])
  /// 索引：按最后访问时间排序
  @@index([lastAccessedAt])
}

/// 消息模型
/// 存储频道中的消息内容
model Message {
  /// 消息唯一标识符
  /// 使用 UUID v7 作为默认值
  messageId String @id @default(uuid(7))

  /// 频道ID
  /// 必填字段，外键关联到 Channel 表
  channelId String

  /// 发送者用户ID
  /// 必填字段，外键关联到 User 表
  userId String

  /// 消息内容
  /// 必填字段，存储消息内容，格式为 JSON 数组
  /// 默认值为空数组 []
  content Json @default("[]")

  /// 创建时间
  /// 自动记录消息发送时间
  createdAt DateTime @default(now())

  /// 更新时间
  /// 自动记录消息编辑时间
  updatedAt DateTime @updatedAt

  /// 关联的频道
  /// 必填字段，建立与 Channel 表的关系
  channel Channel @relation(fields: [channelId], references: [channelId], onDelete: Cascade)

  /// 关联的发送者
  /// 必填字段，建立与 User 表的关系
  user User @relation(fields: [userId], references: [userId], onDelete: Cascade)

  /// 索引：按频道ID查询
  @@index([channelId])
  /// 索引：按用户ID查询
  @@index([userId])
  /// 索引：按创建时间排序
  @@index([createdAt])
  /// 索引：按频道和创建时间排序（用于分页查询）
  @@index([channelId, createdAt])
}

/// 频道类型枚举
/// 定义频道的三种类型
enum ChannelType {
  /// 公开频道：任何人都可以加入
  public
  /// 私密频道：需要邀请才能加入
  private
  /// 直接消息频道：两个用户之间的私聊
  direct
}
