generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

/// 用户模型
/// 存储系统用户的基本信息
model User {
  /// 用户唯一标识符
  /// 使用 UUID v7 作为默认值
  userId String @id @default(uuid(7))

  /// 用户姓名
  /// 必填字段，用于显示用户名称
  userName String

  /// 用户邮箱地址
  /// 可选字段，具有唯一性约束
  email String? @unique

  /// 用户手机号码
  /// 可选字段，具有唯一性约束
  phone String? @unique

  /// 用户密码
  /// 必填字段，使用 argon2 加密存储
  password String

  /// 用户头像
  /// 可选字段，存储用户头像的 URL
  avatar String?

  /// 创建时间
  /// 自动记录用户创建时间
  createdAt DateTime @default(now())

  /// 更新时间
  /// 自动记录用户信息更新时间
  updatedAt DateTime @updatedAt

  /// 用户的认证令牌
  /// 一对多关系，一个用户可以拥有多个认证令牌
  authTokens AuthToken[]

  /// 用户加入的频道
  /// 多对多关系，一个用户可以加入多个频道，一个频道可以有多个用户
  channels Channel[]

  /// 用户的频道元数据
  /// 一对多关系，一个用户在多个频道有元数据记录
  channelUserMetas ChannelUserMeta[]

  /// 用户发送的消息
  /// 一对多关系，一个用户可以发送多条消息
  messages Message[]
}

/// 认证令牌模型
/// 存储用户的认证令牌信息
model AuthToken {
  /// 令牌值
  /// 主键字段，使用 longToken 生成的唯一令牌
  token String @id

  /// 关联的用户ID
  /// 必填字段，外键关联到 User 表
  userId String

  /// 关联的用户
  /// 必填字段，建立与 User 表的关系
  user User @relation(fields: [userId], references: [userId], onDelete: Cascade)

  /// 创建时间
  /// 自动记录令牌创建时间
  createdAt DateTime @default(now())

  /// 最后使用时间
  /// 记录令牌最后一次被使用的时间
  lastUsedAt DateTime @default(now())

  /// 过期时间
  expiresAt DateTime

  /// 索引：按用户ID查询
  @@index([userId])
  /// 索引：按过期时间查询
  @@index([expiresAt])
  /// 索引：按最后使用时间查询
  @@index([lastUsedAt])
}

/// 频道模型
/// 存储频道的基本信息
model Channel {
  /// 频道唯一标识符
  /// 使用 UUID v7 作为默认值
  channelId String @id @default(uuid(7))

  /// 频道名称
  /// 必填字段，用于显示频道名称
  name String

  /// 频道描述
  /// 可选字段，描述频道用途
  description String?

  /// 频道类型
  /// 必填字段，支持公开、私密、直接消息三种类型
  /// public: 公开频道，任何人都可以加入
  /// private: 私密频道，需要邀请才能加入
  /// direct: 直接消息频道，两个用户之间的私聊
  type ChannelType @default(public)

  /// 频道头像
  /// 可选字段，存储频道头像的 URL
  avatar String?

  /// 创建时间
  /// 自动记录频道创建时间
  createdAt DateTime @default(now())

  /// 更新时间
  /// 自动记录频道信息更新时间
  updatedAt DateTime @updatedAt

  /// 频道成员
  /// 多对多关系，一个频道可以有多个成员，一个用户可以加入多个频道
  members User[]

  /// 频道用户元数据记录
  /// 一对多关系，一个频道有多个用户的元数据记录
  channelUserMetas ChannelUserMeta[]

  /// 频道消息
  /// 一对多关系，一个频道包含多条消息
  messages Message[]

  /// 索引：按频道类型查询
  @@index([type])
  /// 索引：按创建时间排序
  @@index([createdAt])
}

/// 频道用户元数据模型
/// 存储用户在频道中的元数据信息，如最后访问时间等
///
/// 设计决策：为什么元数据要单独存储，而不是放在多对多关系中？
/// 1. 关注点分离：多对多关系关注用户与频道的关联，ChannelUserMeta 关注用户在频道中的行为数据
/// 2. 性能优化：访问时间等元数据频繁更新，分开存储可以减少对关系表的锁竞争
/// 3. 数据生命周期不同：用户退出频道时删除关系记录，但可能保留元数据用于分析用户行为
/// 4. 扩展性：未来可以轻松添加更多元数据字段，如消息阅读状态、偏好设置等
/// 5. 查询优化：专门为元数据查询优化索引，提高查询效率
model ChannelUserMeta {
  /// 用户ID
  /// 必填字段，外键关联到 User 表
  userId String

  /// 频道ID
  /// 必填字段，外键关联到 Channel 表
  channelId String

  /// 加入时间
  /// 记录用户加入该频道的时间
  joinedAt DateTime @default(now())

  /// 最后访问时间
  /// 记录用户最后一次访问该频道的时间
  /// 用于判断用户是否阅读了频道中的所有消息
  /// 比较 lastAccessedAt 和消息的 createdAt 可以确定未读消息
  lastAccessedAt DateTime @default(now())

  /// 关联的用户
  /// 必填字段，建立与 User 表的关系
  user User @relation(fields: [userId], references: [userId], onDelete: Cascade)

  /// 关联的频道
  /// 必填字段，建立与 Channel 表的关系
  channel Channel @relation(fields: [channelId], references: [channelId], onDelete: Cascade)

  /// 联合主键：使用 userId 和 channelId 作为复合主键
  @@id([userId, channelId])
  /// 索引：按最后访问时间排序
  @@index([lastAccessedAt])
}

/// 消息模型
/// 存储消息的基本信息和元数据
model Message {
  /// 消息唯一标识符
  /// 使用 UUID v7 作为默认值
  messageId String @id @default(uuid(7))

  /// 频道ID
  /// 必填字段，外键关联到 Channel 表
  channelId String

  /// 发送者用户ID
  /// 必填字段，外键关联到 User 表
  userId String

  /// 创建时间
  /// 自动记录消息发送时间
  createdAt DateTime @default(now())

  /// 更新时间
  /// 自动记录消息编辑时间
  updatedAt DateTime @updatedAt

  /// 关联的频道
  /// 必填字段，建立与 Channel 表的关系
  channel Channel @relation(fields: [channelId], references: [channelId], onDelete: Cascade)

  /// 关联的发送者
  /// 必填字段，建立与 User 表的关系
  user User @relation(fields: [userId], references: [userId], onDelete: Cascade)

  /// 文本内容
  /// 一对多关系，一条消息可以包含多个文本内容
  textContents TextContent[]

  /// 文件内容
  /// 一对多关系，一条消息可以包含多个文件内容
  fileContents FileContent[]

  /// 索引：按频道ID查询
  @@index([channelId])
  /// 索引：按用户ID查询
  @@index([userId])
  /// 索引：按创建时间排序
  @@index([createdAt])
  /// 索引：按频道和创建时间排序（用于分页查询）
  @@index([channelId, createdAt])
}

/// 频道类型枚举
/// 定义频道的三种类型
enum ChannelType {
  /// 公开频道：任何人都可以加入
  public
  /// 私密频道：需要邀请才能加入
  private
  /// 直接消息频道：两个用户之间的私聊
  direct
}

/// 文本内容模型
/// 存储消息的文本内容
model TextContent {
  /// 文本内容唯一标识符
  /// 使用 UUID v7 作为默认值
  contentId String @id @default(uuid(7))

  /// 关联的消息ID
  /// 必填字段，外键关联到 Message 表
  messageId String

  /// 文本内容
  /// 必填字段，存储文本消息内容
  content String

  /// 排序序号
  /// 用于确定内容在消息中的显示顺序
  order Int @default(0)

  /// 关联的消息
  /// 必填字段，建立与 Message 表的关系
  message Message @relation(fields: [messageId], references: [messageId], onDelete: Cascade)

  /// 索引：按消息ID查询
  @@index([messageId])
  /// 索引：按消息和排序序号排序
  @@index([messageId, order])
}

/// 文件内容模型
/// 存储消息的文件内容
model FileContent {
  /// 文件内容唯一标识符
  /// 使用 UUID v7 作为默认值
  contentId String @id @default(uuid(7))

  /// 关联的消息ID
  /// 必填字段，外键关联到 Message 表
  messageId String

  /// 文件URL
  /// 必填字段，存储文件的访问地址
  url String

  /// 文件名称
  /// 必填字段，存储文件的原始名称
  name String

  /// 文件大小（字节）
  /// 必填字段，存储文件的大小
  size Int

  /// 文件MIME类型
  /// 必填字段，存储文件的MIME类型
  mimeType String

  /// 排序序号
  /// 用于确定内容在消息中的显示顺序
  order Int @default(0)

  /// 关联的消息
  /// 必填字段，建立与 Message 表的关系
  message Message @relation(fields: [messageId], references: [messageId], onDelete: Cascade)

  /// 索引：按消息ID查询
  @@index([messageId])
  /// 索引：按消息和排序序号排序
  @@index([messageId, order])
  /// 索引：按MIME类型查询
  @@index([mimeType])
}
